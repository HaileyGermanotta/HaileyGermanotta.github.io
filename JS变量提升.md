## 变量提升 函数声明提升



### 变量提升

`var`声明的变量会提升到函数或全局作用域的最顶部

### 变量重复声明

后面会覆盖前面的，原理如下（引用自网上）

> **引擎**负责整个代码的编译以及运行，**编译器**则负责词法分析、语法分析、代码生成等工作而作用域则如我们熟知的一样，负责维护所有的标识符（变量）。
>
> ​        当我们执行上面的代码时，我们可以简单的理解为新变量分配一块儿内存，命名为a，并赋值为2，但在运行的时候编译器与引擎还会进行两项额外的操作：判断变量是否已经声明：
>
> ​        1.首先编译器对代码进行分析拆解，从左至右遇见var a，则编译器会询问作用域是否已经存在叫a的变量了，如果不存在，则招呼作用域声明一个新的变量a，若已经存在，则忽略var 继续向下编译，这时a = 2被编译成可执行的代码供引擎使用。
>
> ​        2.引擎遇见a=2时同样会询问在当前的作用域下是否有变量a，若存在，则将a赋值为2（由于第一步编译器忽略了重复声明的var，且作用域中已经有a，所以重复声明会发生值得覆盖而并不会报错）。若不存在，则顺着作用域链向上查找，若最终找到了变量a则将其赋值2，若没有找到，则招呼作用域声明一个变量a并赋值为2（这就是为什么第二段代码可以正确执行且a变量为全局变量的原因，当然，在严格模式下JS会直接抛出异常：a is not defined）。

### 函数声明提升

函数表达式方式声明函数，就像变量提升那样

```javascript
var fun = function（）{};
```

```javascript
var fun;
fun = function(){};
```

以上两段代码是等价的



### 函数与变量同时提升 （函数与变量同名）

##### 函数表达式 `var fun = function（）{};`的形式

```javascript
console.log(fun);  //undefined
var fun = function(){};
var fun = "hello world";
console.log(fun); //hello world
```

这种方式就跟上面的变量声明是一个道理的

##### 函数声明 `function fun(){ }`的形式

```javascript
console.log(fun);   //function fun(){}
function fun(){}
var fun = "hello world";
```

这种方式声明函数，函数声明的优先级大于变量声明，故函数**声明**会被提升，同时函数**定义**也会提升，上面代码与以下代码段等价

```javascript
function fun(){}
console.log(fun); // function fun(){}
fun = "hello world";
```



